---
title: "Reporting data results #2"
output: 
  beamer_presentation:
    theme: "metropolis"
fontsize: 10pt
---

```{r echo = FALSE, message = FALSE, warning = FALSE}
library(knitr)
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggthemes)
library(faraway)
data(worldcup)
library(gridExtra)
library(choroplethr)
library(choroplethrMaps)
library(purrr)
library(broom)

add_one <- function(number){
        number + 1 # Value returned by the function
}

fit_ht_wt_mod <- function(df){
  lm(wt ~ ht + sex, data = df) # Returns result from this call
}

nepali <- nepali %>%
  # Limit to certain columns
  select(id, sex, wt, ht, age) %>%
  # Convert id and sex to factors
  mutate(id = factor(id),
         sex = factor(sex, levels = c(1, 2),
                      labels = c("Male", "Female"))) %>%
  # Limit to first obs. per child
  distinct(id, .keep_all = TRUE)
```

# Functional programming

## Applying a function repeatedly 

One way that functions are really useful is that you can use the `map` family of functions from the `purrr` package to apply that function to all elements in a vector of a list (remember, a list could hold lots of similar dataframes). 

For example, you could use `map` to apply the `add_one` function separately to 1, 2, and 3 by using `map` on a vector with those values:

```{r message = FALSE}
library(purrr)
my_list <- list(a = 1:2, b = 3:5)
map(my_list, add_one)
```

## Applying a function repeatedly 

This can also be very useful if you have a dataframe for which you would like to apply the same function to subsets of the data. For example, for the `nepali` data you may want to apply the model of weight regressed on height and sex separately for children 12 months and younger versus older children. 

First, we can add a factor variable that specifies whether the child is younger or older than 12 months:

```{r}
nepali <- nepali %>% 
  mutate(young = age < 12,
         young = factor(young, levels = c(TRUE, FALSE), 
                        labels = c("younger", "older"))) 
```

## Applying a function repeatedly 

```{r}
nepali %>% 
  slice(1:3)
```


## Applying a function repeatedly 

Then, you can use the `nest` function to "nest" a dataframe by a factor variable. This function will create a column that actually stores its own dataframe:

```{r}
nested_nepali <- nepali %>% 
  group_by(young) %>% 
  nest()
nested_nepali
```

## Applying a function repeatedly 

Each element of the `data` column in the nested dataset is actually a full dataframe:

```{r}
nested_nepali$data[[1]] %>% slice(1:3)
```

## Applying a function repeatedly 

Now, you can use `map` to apply the modeling function to each of these subsets of the dataframe. Use `mutate` to add a column with the results. We can also add a column with the results of applying `augment` to each of the model results:

\small

```{r message = FALSE, warning = FALSE}
modeled_nepali <- nepali %>% 
  group_by(young) %>% 
  nest() %>% 
  mutate(mod_results = map(data, fit_ht_wt_mod),
         augmented_data = map(mod_results, augment))
modeled_nepali
```

## Applying a function repeatedly 

Each element of the `mod_results` column is the output from an `lm` model:

```{r}
modeled_nepali$mod_results[[1]]
```

## Applying a function repeatedly 

We can apply `tidy` and `glance` to this output, just like we did with the output from fitting a single model:

```{r}
tidy(modeled_nepali$mod_results[[1]])
```

## Applying a function repeatedly 

To get back to a regular dataframe, you can "unnest". Before you do this, you should limit the data to only columns that will "unnest" to the same number of rows (if you have multiple columns with dataframes or lists in them). For example, we could unnest the `augmented_data` column, so we can plot observed data versus the model fit:

```{r}
modeled_nepali %>% 
  select(young, augmented_data) %>% 
  unnest() %>% 
  slice(1:3) %>% select(1:7)
```

## Applying a function repeatedly 

\small

```{r out.width = "\\textwidth", fig.align = "center", fig.width = 6, fig.height = 2}
modeled_nepali %>% 
  select(young, augmented_data) %>% 
  unnest() %>% 
  ggplot(aes(x = ht, y = wt, group = sex, color = sex)) + 
  geom_point(size = 0.8) + 
  geom_line(aes(y = .fitted), size = 1.2) + 
  facet_wrap(~ young, ncol = 2)
```

## Applying a function repeatedly

The full pipe for creating this figure is: 

```{r eval = FALSE}
nepali %>%
  group_by(young) %>%    # Group by young and nest 
  nest() %>%             # to model each group of "young"
  mutate(mod_results = map(data, fit_ht_wt_mod), 
         augmented_data = map(mod_results, augment)) %>% 
  select(young, augmented_data) %>%  
  unnest %>%             # Unnest `augmented_data` (nested)
  ggplot(aes(x = ht, y = wt, group = sex, color = sex)) + 
  geom_point(size = 0.8) + 
  geom_line(aes(y = .fitted), size = 1.2) + 
  facet_wrap(~ young, ncol = 2)
```


<!-- # Loops -->

<!-- ## Loops -->

<!-- Loops allow you to "walk through" and repeat the same code for different values of an index. \bigskip -->

<!-- For each run of the loop, R is told that, for **some index** in **some vector**, do **some code**. \bigskip -->

<!-- For `i` in `1:3`, `print(i)`: -->

<!-- ```{r} -->
<!-- for(i in c(1, 2, 3)){ -->
<!--         print(i) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Note that this code is equivalent to:  -->

<!-- ```{r} -->
<!-- i <- 1 -->
<!-- print(i) -->
<!-- i <- 2 -->
<!-- print(i) -->
<!-- i <- 3 -->
<!-- print(i) -->
<!-- ``` -->


<!-- ## Loops -->

<!-- Often, the index will be set to a number for each cycle of the loop, and then the index will be used within the code to index vectors or data frames:  -->

<!-- ```{r} -->
<!-- study_months <- c("Jan", "Feb", "Mar") -->
<!-- for(i in c(1, 3)){ -->
<!--         print(study_months[i]) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Often, you want to set the index to sequential numbers (e.g., 1, 2, 3, 4). In this case, you can save time by using the `:` notation to create a vector of a sequence of numbers: -->

<!-- ```{r} -->
<!-- for(i in 1:3){ -->
<!--         print(i) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- With this notation, sometimes it may be helpful to use the `length` function to set the largest index value for the loop as the length of a vector (or `nrow` for indexing a data frame). For example: -->

<!-- ```{r} -->
<!-- study_months <- c("Jan", "Feb", "Mar") -->
<!-- for(i in 1:length(study_months)){ -->
<!--         print(study_months[i]) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Sometimes, you want to set the index for each cycle of the loop to something that is not a number. You can set the index to any class of vector. \bigskip -->

<!-- Remember that a loop works by saying for **some index** in **some vector**, do **some code**. \bigskip -->

<!-- For example, you may want to run: for `study_month` in `study_months`, `print(study_month)`: -->

<!-- ```{r} -->
<!-- study_months <- c("Jan", "Feb", "Mar") -->
<!-- for(study_month in study_months){ -->
<!--         print(study_month) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Note that this is equivalent to:  -->

<!-- ```{r} -->
<!-- study_month <- "Jan" -->
<!-- print(study_month) -->
<!-- study_month <- "Feb" -->
<!-- print(study_month) -->
<!-- study_month <- "Mar" -->
<!-- print(study_month) -->
<!-- ``` -->

<!-- ## Loops -->

<!-- What would this loop do? -->

<!-- ```{r, eval = FALSE} -->
<!-- vars <- c("Time", "Shots", "Passes", "Tackles", "Saves") -->
<!-- for(i in 1:length(vars)){ -->
<!--         var_mean <- mean(worldcup[ , vars[i]]) -->
<!--         print(var_mean) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- ```{r} -->
<!-- vars <- c("Time", "Shots", "Passes", "Tackles", "Saves") -->
<!-- for(i in 1:length(vars)){ -->
<!--         var_mean <- mean(worldcup[ , vars[i]]) -->
<!--         print(var_mean) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- What would this loop do? -->

<!-- ```{r, eval = FALSE} -->
<!-- vars <- c("Time", "Shots", "Passes", "Tackles", "Saves") -->
<!-- for(i in 1:length(vars)){ -->
<!--         var_mean <- mean(worldcup[ , vars[i]]) -->
<!--         var_mean <- round(var_mean, 1) -->
<!--         out <- paste0("mean of ", vars[i], ": ", var_mean) -->
<!--         print(out) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- To figure out, you can set `i <- 1` and then walk through the loop: -->

<!-- ```{r} -->
<!-- i <- 1 -->
<!-- (var_mean <- mean(worldcup[ , vars[i]])) -->
<!-- (var_mean <- round(var_mean, 1)) -->
<!-- (out <- paste0("mean of ", vars[i], ": ", var_mean)) -->
<!-- ``` -->

<!-- ## Loops -->

<!-- ```{r} -->
<!-- vars <- c("Time", "Shots", "Passes", "Tackles", "Saves") -->
<!-- for(i in 1:length(vars)){ -->
<!--         var_mean <- mean(worldcup[ , vars[i]]) -->
<!--         var_mean <- round(var_mean, 1) -->
<!--         out <- paste0("mean of ", vars[i], ": ", var_mean) -->
<!--         print(out) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Often, it's convenient to create a data set to fill up as you loop through: -->

<!-- ```{r, eval = FALSE} -->
<!-- vars <- c("Time", "Shots", "Passes", "Tackles", "Saves") -->
<!-- my_df <- data.frame(variable = vars, mean = NA) -->
<!-- for(i in 1:nrow(my_df)){ -->
<!--         var_mean <- mean(worldcup[ , vars[i]]) -->
<!--         my_df[i , "mean"] <- round(var_mean, 1) -->
<!-- } -->
<!-- ``` -->

<!-- ## Loops -->

<!-- ```{r} -->
<!-- vars <- c("Time", "Shots", "Passes", "Tackles", "Saves") -->
<!-- (my_df <- data.frame(variable = vars, mean = NA)) -->
<!-- ``` -->

<!-- ## Loops -->
<!-- ```{r} -->
<!-- i <- 1 -->
<!-- (var_mean <- mean(worldcup[ , vars[i]])) -->
<!-- my_df[i , "mean"] <- round(var_mean, 1) -->
<!-- my_df -->
<!-- ``` -->

<!-- ## Loops -->

<!-- ```{r} -->
<!-- for(i in 1:nrow(my_df)){ -->
<!--         var_mean <- mean(worldcup[ , vars[i]]) -->
<!--         my_df[i , "mean"] <- round(var_mean, 1) -->
<!-- } -->
<!-- my_df -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Note: This is a pretty simplistic example. There are some easier ways to have done this: -->

<!-- ```{r} -->
<!-- worldcup %>%  -->
<!--   summarize(Time = mean(Time), Passes = mean(Passes), -->
<!--             Shots = mean(Shots), Tackles = mean(Tackles), -->
<!--             Saves = mean(Saves)) %>% -->
<!--   gather(key = var, value = mean) %>% -->
<!--   mutate(mean = round(mean, 1)) -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Note: This is a pretty simplistic example. There are some easier ways to have done this: -->

<!-- ```{r} -->
<!-- means <- apply(worldcup[ , vars], 2, mean) -->
<!-- (means <- round(means, 1)) -->
<!-- ``` -->

<!-- However, you can use this same looping process for much more complex tasks that you can't do as easily with `apply` or `dplyr` tools. -->

<!-- ## Loops -->

<!-- Loops can be very useful for more complex repeated tasks. For example: -->

<!-- ```{r, echo = FALSE, fig.width = 6, fig.height = 4} -->
<!-- positions <- unique(worldcup$Position) -->
<!-- pos_est <- data.frame(position = positions, -->
<!--                       est = NA, se = NA) -->

<!-- for(i in 1:nrow(pos_est)){ -->
<!--         pos_df <- worldcup %>%  -->
<!--           filter(Position == positions[i])  -->
<!--         pos_mod <- glm(Passes ~ Time, -->
<!--                        data = pos_df, -->
<!--                        family = poisson(link = "log")) -->
<!--         pos_coefs <- summary(pos_mod)$coefficients[2, 1:2] -->
<!--         pos_est[i, c("est", "se")] <- pos_coefs -->
<!-- } -->

<!-- pos_est <- pos_est %>% -->
<!--   mutate(lower_ci = est - 1.96 * se, -->
<!--          upper_ci = est + 1.96 * se) -->

<!-- rr_per90 <- function(est){ -->
<!--         out <- exp(est * 90) -->
<!--         return(out) -->
<!-- } -->

<!-- pos_est[ , c("rr_est", "rr_low", "rr_high")] <-  -->
<!--         apply(pos_est[ , c("est", "lower_ci", "upper_ci")], 2, rr_per90) -->

<!-- pos_est <- arrange(pos_est, rr_est) %>% -->
<!--         mutate(position = factor(position, levels = position)) -->

<!-- ggplot(pos_est, aes(x = rr_low, y = position)) +  -->
<!--         geom_segment(aes(xend = rr_high, yend = position)) +  -->
<!--         geom_point(aes(x = rr_est, y = position)) +  -->
<!--         theme_few() +  -->
<!--         ylab("") +  -->
<!--         scale_x_continuous("Relative rate of passes\nper 90 minute increase in minutes played", -->
<!--                            limits = c(1.0, max(pos_est$rr_high))) +  -->
<!--         geom_vline(aes(xintercept = 1), color = "lightgray") -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Creating this graph requires:  -->

<!-- - Create a subset limited to each of the four positions -->
<!-- - Fit a Poisson regression of Passes on Time within each subset -->
<!-- - Pull the regression coefficient and standard error from each model -->
<!-- - Use those values to calculate 95% confidence intervals -->
<!-- - Convert everything from log relative rate to relative rate -->
<!-- - Plot everything -->

<!-- ## Loops -->

<!-- Create a vector with the names of all positions. Create an empty data frame to store regression results. -->

<!-- ```{r} -->
<!-- (positions <- unique(worldcup$Position)) -->
<!-- (pos_est <- data.frame(position = positions, -->
<!--                        est = NA, se = NA)) -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Loop through and fit a Poisson regression model for each subset of data. Save regression coefficients in the empty data frame. -->

<!-- ```{r} -->
<!-- for(i in 1:nrow(pos_est)){ -->
<!--         pos_df <- worldcup %>% -->
<!--           filter(Position == positions[i])  -->
<!--         pos_mod <- glm(Passes ~ Time, -->
<!--                        data = pos_df, -->
<!--                        family = poisson(link = "log")) -->
<!--         pos_coefs <- summary(pos_mod)$coefficients[2, 1:2] -->
<!--         pos_est[i, c("est", "se")] <- pos_coefs -->
<!-- } -->
<!-- pos_est[1:2, ] -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Calculate 95% confidence intervals for log relative risk values. -->

<!-- ```{r} -->
<!-- pos_est <- pos_est %>% -->
<!--   mutate(lower_ci = est - 1.96 * se, -->
<!--          upper_ci = est + 1.96 * se) -->

<!-- pos_est %>% -->
<!--   select(position, est, lower_ci, upper_ci)  -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Calculate relative risk per 90 minute increase in minutes played.  -->

<!-- ```{r} -->
<!-- pos_est <- pos_est %>% -->
<!--   mutate(rr_est = exp(90 * est), -->
<!--          rr_low = exp(90 * lower_ci), -->
<!--          rr_high = exp(90 * upper_ci)) -->
<!-- pos_est %>% -->
<!--   select(position, rr_est, rr_low, rr_high)  -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Re-level the `position` factor so the plot will be ordered from highest to lowest estimates. -->

<!-- ```{r} -->
<!-- pos_est <- arrange(pos_est, rr_est) %>% -->
<!--         mutate(position = factor(position, -->
<!--                                  levels = position)) -->
<!-- pos_est %>% select(position, est) -->
<!-- ``` -->

<!-- ## Loops -->

<!-- Create the plot: -->

<!-- ```{r, eval = FALSE} -->
<!-- ggplot(pos_est, aes(x = rr_low, y = position)) +  -->
<!--         geom_segment(aes(xend = rr_high, yend = position)) +  -->
<!--         geom_point(aes(x = rr_est, y = position)) +  -->
<!--         theme_few() +  -->
<!--         ylab("") +  -->
<!--         scale_x_continuous(paste("Relative rate of",  -->
<!--                                  "passes\nper 90 minute",  -->
<!--                                  "increase in minutes played"), -->
<!--                            limits = c(1.0,  -->
<!--                                       max(pos_est$rr_high))) +  -->
<!--         geom_vline(aes(xintercept = 1), color = "lightgray") -->
<!-- ``` -->

<!-- ## Loops -->

<!-- ```{r, echo = FALSE, fig.width = 6, fig.height = 4} -->
<!-- ggplot(pos_est, aes(x = rr_low, y = position)) +  -->
<!--         geom_segment(aes(xend = rr_high, yend = position)) +  -->
<!--         geom_point(aes(x = rr_est, y = position)) +  -->
<!--         theme_few() +  -->
<!--         ylab("") +  -->
<!--         scale_x_continuous(paste("Relative rate of passes\nper", -->
<!--                                  "90 minute increase in minutes played"), -->
<!--                            limits = c(1.0, max(pos_est$rr_high))) +  -->
<!--         geom_vline(aes(xintercept = 1), color = "lightgray") -->
<!-- ``` -->

# Point maps

## Point maps 

It is very easy to create point maps in R based on longitude and latitude values of specific locations. \bigskip

To get a base map, you can use the `map_data` function from the `ggplot2` package to pull data for maps at different levels ("usa", "state", "world", "county").

## Point maps 

The maps you pull using `map_data` are just data frames. They include the data you need to plot polygon shapes for areas like states and counties. 

```{r warning = FALSE, message = FALSE}
library(ggplot2)
us_map <- map_data("state")
head(us_map, 3)
```

You can add points to these based on latitude and longitude.

## Point maps 

Map choices with `map_data` are currently limited to: 

- `county`
- `state`
- `usa`
- `france`
- `italy`
- `nz`
- `world`
- `world2`

## Point maps 

Mapping uses the `long` and `lat` columns from this data for location:

```{r fig.width = 6, fig.height = 2.5, fig.align = "center"}
north_carolina <- us_map %>% 
  filter(region == "north carolina")
ggplot(north_carolina, aes(x = long, y = lat)) +
  geom_point() 
```

## Point maps 

If you try to plot lines, however, you'll have a problem:

```{r fig.width = 3.5, fig.height = 2.25, fig.align = "center"}
carolinas <- us_map %>% 
  filter(str_detect(region, "carolina"))
ggplot(carolinas, aes(x = long, y = lat)) + 
  geom_path()
```

## Point maps 

The `group` column fixes this problem. It will plot a separate path or polygon for each separate group. For mapping, this gives separate groupings for mainland versus islands and for different states:

```{r}
carolinas %>%
  group_by(group) %>%
  slice(1)
```

## Point maps

Using `group = group` avoids the extra lines from the earlier map:

```{r fig.width = 3.5, fig.height = 2.25, fig.align = "center"}
ggplot(carolinas, aes(x = long, y = lat,
                      group = group)) + 
  geom_path()
```

## Point maps

To plot filled regions, use `geom_polygon` with `fill = region`. Also, the "void" theme is often useful when mapping:

```{r fig.width = 4.5, fig.height = 2, fig.align = "center"}
ggplot(carolinas, aes(x = long, y = lat,
                      group = group,
                      fill = region)) + 
  geom_polygon(color = "black") + 
  theme_void()
```

## Point maps 

Here is an example of plotting all of the US by state:

```{r}
map_1 <- ggplot(us_map, aes(x = long, y = lat,
                            group = group)) + 
        geom_polygon(fill = "dodgerblue",
                     color = "white") +
        theme_void()
```

## Point maps

```{r fig.width = 6.5, fig.height = 4, fig.align = "center"}
map_1
```

## Point maps 

To add points to these maps, you can use `geom_point`, again using longitude and latitude to define position. \bigskip

Here I'll use an example of data points related to the story told in last year's ["Serial" podcast](http://serialpodcast.org). 

```{r}
serial <- read.csv("../data/serial_map_data.csv")
head(serial, 3)
```

## Point maps 

[David Robinson](https://github.com/dgrtwo/serial-ggvis/blob/master/serial-preprocessing.Rmd) figured out a way to convert the x and y coordinates in this data to latitude and longitude coordinates. I'm also adding a column for whether of not the point is a cell tower.

```{r message = FALSE, warning = FALSE}
library(dplyr)
serial <- serial %>%
    mutate(long = -76.8854 + 0.00017022 * x,
           lat  = 39.23822 + 1.371014e-04 * y,
           tower = Type == "cell-site")
```

## Point maps 

```{r message = FALSE, warning = FALSE}
serial[c(1:2, (nrow(serial) - 1):nrow(serial)), 
       c("Type", "Name", "long", "lat", "tower")]
```

## Point maps 

Now I can map just Baltimore City and Baltimore County in Maryland and add these points. \bigskip

I used `map_data` to pull the "county" map and specified "region" as "maryland", to limit the map just to Maryland counties. 

```{r}
baltimore <- map_data('county', region = 'maryland')
head(baltimore, 3)
```

## Point maps

From that, I filter to just rows where the `subregion` column was "baltimore city" or "baltimore". 

```{r}
baltimore <- baltimore %>%
  filter(subregion %in% c("baltimore city",
                          "baltimore"))
head(baltimore, 3)
```

## Point maps

I used `geom_point` to plot the points. When you plot points, you need to "ungroup" the `group` column you used to plot the polygons for counties. To do that, set `group = NA` in the `geom_point` statement. 

```{r}
balt_plot <- ggplot(baltimore, 
                    aes(x = long, y = lat, group = group)) + 
        geom_polygon(fill = "lightblue", color = "black") +
        geom_point(data = serial, aes(x = long, y = lat,
                                      group = NA,
                                      color = tower)) + 
        theme_bw()
```

## Point maps

```{r fig.width = 7, fig.height = 4}
balt_plot
```

# Choropleths

## Choropleths in R

There's a fantastic new(-ish) package in R to plot choropleth maps. You could also plot choropleths using `ggplot` and other mapping functions, but I would strongly recommend this new package if you're mapping the US. \bigskip

You will need to install and load the `choroplethr` package in R to use the functions below.

```{r message = FALSE, warning = FALSE}
# install.packages("choroplethr")
library(choroplethr)

# install.packages("choroplethrMaps")
library(choroplethrMaps)
```

## Choropleths in R

At the most basic level, you can use this package to plot some data that comes automatically with the package (you'll just need to load the data using the `data` function). For example, if you wanted to plot state-by-state populations as of 2012, you could use:

```{r warning = FALSE, message=FALSE}
data(df_pop_state)
map_3 <- state_choropleth(df_pop_state)
```

## Choropleths in R

```{r fig.width=8, fig.height=3.5}
map_3
```


## Choropleths in R

You can find out more about the `df_pop_state` data if you type `?df_pop_state`. Notice that, for the data frame, the location is given in a column called `region` and the population size to plot is in a column called `value`. 

```{r}
head(df_pop_state, 3)
```


## Choropleths in R

You could use this function to create any state-level choropleth you wanted, as long as you could create a data frame with a column for states called `region` and a column with the value you want to show called `value`.

## Choropleths in R

You can run similar functions at different spatial resolutions (for example, county or zip code):

```{r}
data(df_pop_county)
head(df_pop_county, 3)
```

## Choropleths in R

You can plot choropleths at this level, as well:

```{r warning = FALSE, message = FALSE}
map_4 <- county_choropleth(df_pop_county)
```

## Choropleths in R

```{r fig.width=8, fig.height=4}
map_4
```


## Choropleths in R

You can even do this for countries of the world:

```{r fig.width = 8, fig.height = 3.5, warning=FALSE, message=FALSE}
data(df_pop_country)
country_choropleth(df_pop_country)
```

## Choropleths in R

You can zoom into states or counties. For example, to plot population by county in Colorado, you could run:

```{r fig.width = 6, fig.height = 3, message = FALSE, warning = FALSE}
county_choropleth(df_pop_county, state_zoom = "colorado")
```

## Choropleths in R

You can also use this package to map different tables from the US Census' American Community Survey. \bigskip 

The package includes the `choroplethr_acs()` function to do this, with an option for which level of map you want (`map = `, choices are "state", "country", and "zip"). If you want to map at the state level, for example, use `state_choroplethr_acs()` (other options are county level and zip code level). 

## Choropleths in R

These functions pull recent Census data directly from the US Census using its API, so they require you to get an API key, which you can get [here](http://api.census.gov/data/key_signup.html). \bigskip

Once you put in your request, they'll email you your key. Once they give you your API key, you'll need to install it on R:

```{r echo = FALSE, message = FALSE, warning = FALSE}
library(acs)
api.key.install(Sys.getenv("acskey"))
```

```{r eval = FALSE}
library(acs)
api.key.install('[your census api key]');
```

## Choropleths in R

You can pick from a large number of American Community Survey tables-- [see here](http://factfinder.census.gov/faces/affhelp/jsf/pages/metadata.xhtml?lang=en&type=dataset&id=dataset.en.ACS_12_5YR) for the list plus ID numbers. If the table has multiple columns, you will be prompted to select which one you want to plot. \bigskip

## Choropleths in R

For example, table B19301 gives per-capita income, so if you wanted to plot that, you could run:

```{r fig.width = 3, fig.height = 2.75, message = FALSE, eval = FALSE}
county_choropleth_acs(tableId = "B19301",
                       state_zoom = c("wyoming",
                                      "colorado"))

```

## Choropleths in R

```{r fig.width = 10, fig.height = 6, message = FALSE, echo = FALSE, fig.align = "center"}
county_choropleth_acs(tableId = "B19301",
                       state_zoom = c("wyoming",
                                      "colorado"))

```


## Google Maps API

The `ggmap` package allows you to use tools from Google Maps directly from R.

```{r message=FALSE, warning = FALSE}
## install.packages("ggmap")
library(ggmap)
```

This package uses the Google Maps API, so you should read their [terms of service](http://developers.google.com/maps/terms) and make sure you follow them. In particular, you are limited to just a certain number of queries per time. 

## Google Maps API

You can use the `get_map` function to get maps for different locations. \bigskip 

You can either use the longitude and latitude of the center point of the map, along with the `zoom` option to say how much to zoom in (3: continent to 20: building) or you can use a character string to specify a location. \bigskip

If you do the second, `get_map` will actually use the Google Maps API to geocode the string to a latitude and longitude and then get the map (you can imagine that this is like searching in Google Maps in the search box for a location).

```{r message = FALSE, warning = FALSE, fig.width = 3.5, fig.height = 3.5, fig.align = "center", eval = FALSE}
beijing <- get_map("Beijing", zoom = 12)
ggmap(beijing)
```

## Google Maps API

```{r message = FALSE, warning = FALSE, fig.width = 3.5, fig.height = 3.5, fig.align = "center", echo = FALSE}
beijing <- get_map("Beijing", zoom = 12)
ggmap(beijing)
```

## Google Maps API

With this package, you can get maps from the following different sources:

- Google Maps
- OpenStreetMap
- Stamen Maps
- CloudMade Maps (You may need a separate API key for this)

## Google Maps API

Here are different examples of Beijing using different map sources. (Also, note that I'm using the option `extent = "device"` to fill up the whole plot are with the map, instead of including axis labels and titles.)

```{r message = FALSE, warning = FALSE}
beijing_a <- get_map("Beijing", zoom = 12,
                     source = "stamen", maptype = "toner")
a <- ggmap(beijing_a, extent = "device")

beijing_b <- get_map("Beijing", zoom = 12,
                     source = "stamen", maptype = "watercolor")
b <- ggmap(beijing_b, extent = "device")

beijing_c <- get_map("Beijing", zoom = 12,
                     source = "google", maptype = "hybrid")
c <- ggmap(beijing_c, extent = "device")
```

## Google Maps API

```{r fig.width = 7}
grid.arrange(a, b, c, nrow = 1) 
```


## Google Maps API

As with the maps from `ggplot2`, you can add points to these maps:

```{r warning = FALSE, message = FALSE, echo = FALSE}
library(tidyr)
serial_phone <- read.csv("../data/serial_phone_data.csv") %>% 
        mutate(Cell_Site = substring(Cell_Site, 1, 4),
               Call_Time = as.POSIXct(Call_Time, format = "%d/%m/%y %H:%M",
                                      tz = "EST")) %>%
        left_join(serial, by = c("Cell_Site" = "Name")) %>%
        select(Person_Called, Call_Time, Duration, long, lat) %>%
        filter(!(Person_Called %in% c("incoming", "# + Adnan cell"))) %>%
        arrange(Call_Time)
```

```{r message = FALSE, warning = FALSE, fig.width = 5}
serial_map <- get_map(c(-76.7, 39.3), zoom = 12,
                      source = "stamen",
                      maptype = "toner")
serial_map <- ggmap(serial_map, extent = "device") + 
        geom_point(data = serial_phone,
                   aes(x = long, y = lat),
                   color = "red", size = 3,
                   alpha = 0.4) +
        geom_point(data = subset(serial,
                                 Type != "cell-site"),
                   aes(x = long, y = lat),
                   color = "darkgoldenrod1",
                   size = 2)
```

## Google Maps API

```{r warning = FALSE, message = FALSE, fig.width = 4, fig.height = 4, fig.align = "center", echo = FALSE}
serial_map
```


## Google Maps API

You can also use the Google Maps API, through the `geocode` function, to get the latitude and longitude of specific locations. Basically, if the string would give you the right location if you typed it in Google Maps, `geocode` should be able to geocode it.

For example, you can get the location of CSU:

```{r message = FALSE, warning = FALSE}
geocode("Colorado State University")
```

## Google Maps API

You can also get a location by address through this:

```{r message = FALSE, warning = FALSE}
geocode("1 First St NE, Washington, DC")
```

## Google Maps API

You can get distances, too, using the `mapdist` function with two locations. This will give you distance and also time. 

```{r message = FALSE, warning = FALSE}
mapdist("Fort Collins CO",
        "1 First St NE, Washington, DC") %>%
  select(from, miles, hours)
```
